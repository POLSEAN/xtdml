}else if({lrn}=="xgboost"){
dml_obj = dml_xgboost(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = "y", d_cols = "d", z_cols = zlist,
cluster_cols="id")
}else if ({lrn}=="nnet"){
# min-max normalisation
main = select(dta, c(x_cols, Lx_cols))
maxs = apply(main, 2, max)
mins = apply(main, 2, min)
scaled = as.data.frame(scale(main, center = mins, scale = maxs - mins))
scaled$y = dta$y
scaled$id= dta$id
scaled$time = dta$time
scaled$d = dta$d
scaled$z = dta[zlist]
dta2 <- scaled %>% select(c(id,time,y,d,z), everything())
#z = paste0("x", 29:30)
dml_obj = dml_nnet(df = dta2,
x_cols = c(x_cols,Lx_cols), y_col = "y", d_cols = "d", z_cols = zlist,
cluster_cols="id")
}
# DML estimation
dml_obj$fit()
dml_obj$print()
dml_obj$confint()
#print(dml_obj$params)
# # Display table that compares results
# table[,i] = cbind(dml_obj$coef_theta,
#                   dml_obj$se_theta,
#                   dml_obj$pval_theta,
#                   dml_obj$model_rmse,
#                   as.numeric(dml_obj$rmses["ml_l"]),
#                   as.numeric(dml_obj$rmses["ml_r"]),
#                   dml_obj$coef_pi,
#                   dml_obj$se_pi,
#                   dml_obj$pval_pi,
#                   as.numeric(dml_obj$rmses["ml_m"]),
#                   dml_obj$ARF,
#                   dml_obj$ARFp,
#                   dml_obj$ARchi2p)
#
# rownames(table)= c("Estimate theta", "Std. Error theta", "P-value theta",
#                    "Model RMSE", "MSE of l", "MSE of r",
#                    "Estimate pi", "Std. Error pi", "P-value pi", "MSE of m",
#                    "Estimate delta", "Std. Error delta", "P-value delta")
# colnames(table)= c( "DML-LASSO", "DML-CART", "DML-RF" , "DML-XGBOOST", "DML-Nnet")
# print(table)
#
# i = i + 1
}
}
devtools::load_all(wd.pack)
approaches <- c('exact') #, 'wg')
learners   <- c('rpart') #'lasso', 'rpart', 'rf','xgboost','nnet')
for (appr in approaches){
for (lrn in learners){
print(glue("Learner: {lrn}; approach: {appr}"))
#______________________________________________________________________________#
# Simulation parameters
#______________________________________________________________________________#
set.seed(1408)
# Set up DML data and estimation environment (calls functions in 003_dml_functions_approx_and_exact.R)
if({lrn}=="lasso"){
dml_obj = dml_lasso(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = "y", d_cols = "d", z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="rf"){
dml_obj = dml_rf(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = "y", d_cols = "d", z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="rpart"){
dml_obj = dml_rpart(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = "y", d_cols = "d", z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="xgboost"){
dml_obj = dml_xgboost(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = "y", d_cols = "d", z_cols = zlist,
cluster_cols="id")
}else if ({lrn}=="nnet"){
# min-max normalisation
main = select(dta, c(x_cols, Lx_cols))
maxs = apply(main, 2, max)
mins = apply(main, 2, min)
scaled = as.data.frame(scale(main, center = mins, scale = maxs - mins))
scaled$y = dta$y
scaled$id= dta$id
scaled$time = dta$time
scaled$d = dta$d
scaled$z = dta[zlist]
dta2 <- scaled %>% select(c(id,time,y,d,z), everything())
#z = paste0("x", 29:30)
dml_obj = dml_nnet(df = dta2,
x_cols = c(x_cols,Lx_cols), y_col = "y", d_cols = "d", z_cols = zlist,
cluster_cols="id")
}
# DML estimation
dml_obj$fit()
dml_obj$print()
dml_obj$confint()
#print(dml_obj$params)
# # Display table that compares results
# table[,i] = cbind(dml_obj$coef_theta,
#                   dml_obj$se_theta,
#                   dml_obj$pval_theta,
#                   dml_obj$model_rmse,
#                   as.numeric(dml_obj$rmses["ml_l"]),
#                   as.numeric(dml_obj$rmses["ml_r"]),
#                   dml_obj$coef_pi,
#                   dml_obj$se_pi,
#                   dml_obj$pval_pi,
#                   as.numeric(dml_obj$rmses["ml_m"]),
#                   dml_obj$ARF,
#                   dml_obj$ARFp,
#                   dml_obj$ARchi2p)
#
# rownames(table)= c("Estimate theta", "Std. Error theta", "P-value theta",
#                    "Model RMSE", "MSE of l", "MSE of r",
#                    "Estimate pi", "Std. Error pi", "P-value pi", "MSE of m",
#                    "Estimate delta", "Std. Error delta", "P-value delta")
# colnames(table)= c( "DML-LASSO", "DML-CART", "DML-RF" , "DML-XGBOOST", "DML-Nnet")
# print(table)
#
# i = i + 1
}
}
rm(list = ls())
#install.packages("mlr3pipelines")
# library(roxygen2)  # for documenting your functions
# library(devtools)  # for building R packages
# library(mlr3pipelines)
wd.pack = "C:/Users/annal/Dropbox/IADS/dml/DML-IV/XTDML"
devtools::load_all(wd.pack)
#devtools::check(wd.pack)
wd = "C:/Users/annal/Dropbox/IADS/dml/DML-IV"
library(paradox)
library(mlr3tuning)
library(mlr3misc)
# library(glmnet)
# library(ranger)
library(paradox)
library(mlr3tuning)
# general packages
library(tibble)  ##for add_column()
library(dplyr)   ##for mutate()
library(datawizard)
library(glue)
library(devtools)
library(data.table)
library(sandwich) # for clustered std errors
library(lmtest) # for coeftest
library(sparseinv) #for cholsolve()
library(stats)
#lgr::get_logger("mlr3")$set_threshold("warn")
#lgr::get_logger("bbotk")$set_threshold("warn")
#______________________________________________________________________________#
# Load functions
#source("C:/Users/annal/Dropbox/IADS/dml/DML-IV/r/003_dml_functions_approx_and_exact.R")
source(glue("{wd}/check_files_for_ap/003_dml_functions_approx_and_exact.R"))
# Load data
#dta = read.csv("C:/Users/annal/Dropbox/IADS/R_codes/CREDML/data/dgp4_cre_short.csv")
#dta = read.csv(glue("{wd}/csv/short_for_github/dgp3_fd_iv_short.csv")) # toy dataset
dta = read.csv(glue("{wd}/csv/new/dgp_2sls_interaction_v8.csv")) #currently used for simulations
x_cols = paste0("X", 1:30)
Lx_cols = paste0("L.X", 1:30)
dta$zweak = rnorm(9000,0,0.25)  # Z eqn
dta$zweak2 = rnorm(9000,5,1)  # Z eqn
zlist = names(select(dta, c("z_31"))) #c("z","z2","z3")
yvar = names(select(dta, c("y_31")))
dvar = names(select(dta, c("d_31")))
obj_dml_data = dml_transform_data_from_data_frame(dta,
x_cols = c(x_cols,Lx_cols),  y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols = "id")
print(obj_dml_data)
#______________________________________________________________________________#
rm(table)
table = matrix(0, 13,5)
i = 1
approaches <- c('exact') #, 'wg')
learners   <- c('rpart') #'lasso', 'rpart', 'rf','xgboost','nnet')
for (appr in approaches){
for (lrn in learners){
print(glue("Learner: {lrn}; approach: {appr}"))
#______________________________________________________________________________#
# Simulation parameters
#______________________________________________________________________________#
set.seed(1408)
# Set up DML data and estimation environment (calls functions in 003_dml_functions_approx_and_exact.R)
if({lrn}=="lasso"){
dml_obj = dml_lasso(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="rf"){
dml_obj = dml_rf(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="rpart"){
dml_obj = dml_rpart(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="xgboost"){
dml_obj = dml_xgboost(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if ({lrn}=="nnet"){
# min-max normalisation
main = select(dta, c(x_cols, Lx_cols))
maxs = apply(main, 2, max)
mins = apply(main, 2, min)
scaled = as.data.frame(scale(main, center = mins, scale = maxs - mins))
scaled$y = dta[[yvar]]
scaled$id= dta$id
scaled$time = dta$time
scaled$d = dta[[dvar]]
scaled$z = dta[zlist]
dta2 <- scaled %>% select(c(id,time,y,d,z), everything())
#z = paste0("x", 29:30)
dml_obj = dml_nnet(df = dta2,
x_cols = c(x_cols,Lx_cols), y_col = "y", d_cols = "d", z_cols = paste0("z.", zlist),
cluster_cols="id")
}
# DML estimation
dml_obj$fit()
dml_obj$print()
dml_obj$confint()
#print(dml_obj$params)
print(cat(paste0(dml_obj$ARroot1, collapse = "\n")))
print(cat(paste0(dml_obj$ARroot2, collapse = "\n")))
# # Display table that compares results
# table[,i] = cbind(dml_obj$coef_theta,
#                   dml_obj$se_theta,
#                   dml_obj$pval_theta,
#                   dml_obj$model_rmse,
#                   as.numeric(dml_obj$rmses["ml_l"]),
#                   as.numeric(dml_obj$rmses["ml_r"]),
#                   dml_obj$coef_pi,
#                   dml_obj$se_pi,
#                   dml_obj$pval_pi,
#                   as.numeric(dml_obj$rmses["ml_m"]),
#                   dml_obj$ARF,
#                   dml_obj$ARFp,
#                   dml_obj$ARchi2p)
# #
# rownames(table)= c("Estimate theta", "Std. Error theta", "P-value theta",
#                    "Model RMSE", "MSE of l", "MSE of r",
#                    "Estimate pi", "Std. Error pi", "P-value pi", "MSE of m",
#                    "Estimate delta", "Std. Error delta", "P-value delta")
# colnames(table)= c( "DML-LASSO", "DML-CART", "DML-RF" , "DML-XGBOOST", "DML-Nnet")
# print(table)
#
# i = i + 1
}
}
zlist = names(select(dta, c("z_weak"))) #c("z","z2","z3")
zlist = names(select(dta, c("zweak"))) #c("z","z2","z3")
yvar = names(select(dta, c("y_31")))
dvar = names(select(dta, c("d_31")))
obj_dml_data = dml_transform_data_from_data_frame(dta,
x_cols = c(x_cols,Lx_cols),  y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols = "id")
print(obj_dml_data)
#______________________________________________________________________________#
rm(table)
table = matrix(0, 13,5)
i = 1
approaches <- c('exact') #, 'wg')
learners   <- c('rpart') #'lasso', 'rpart', 'rf','xgboost','nnet')
for (appr in approaches){
for (lrn in learners){
print(glue("Learner: {lrn}; approach: {appr}"))
#______________________________________________________________________________#
# Simulation parameters
#______________________________________________________________________________#
set.seed(1408)
# Set up DML data and estimation environment (calls functions in 003_dml_functions_approx_and_exact.R)
if({lrn}=="lasso"){
dml_obj = dml_lasso(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="rf"){
dml_obj = dml_rf(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="rpart"){
dml_obj = dml_rpart(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="xgboost"){
dml_obj = dml_xgboost(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if ({lrn}=="nnet"){
# min-max normalisation
main = select(dta, c(x_cols, Lx_cols))
maxs = apply(main, 2, max)
mins = apply(main, 2, min)
scaled = as.data.frame(scale(main, center = mins, scale = maxs - mins))
scaled$y = dta[[yvar]]
scaled$id= dta$id
scaled$time = dta$time
scaled$d = dta[[dvar]]
scaled$z = dta[zlist]
dta2 <- scaled %>% select(c(id,time,y,d,z), everything())
#z = paste0("x", 29:30)
dml_obj = dml_nnet(df = dta2,
x_cols = c(x_cols,Lx_cols), y_col = "y", d_cols = "d", z_cols = paste0("z.", zlist),
cluster_cols="id")
}
# DML estimation
dml_obj$fit()
dml_obj$print()
dml_obj$confint()
#print(dml_obj$params)
print(cat(paste0(dml_obj$ARroot1, collapse = "\n")))
print(cat(paste0(dml_obj$ARroot2, collapse = "\n")))
# # Display table that compares results
# table[,i] = cbind(dml_obj$coef_theta,
#                   dml_obj$se_theta,
#                   dml_obj$pval_theta,
#                   dml_obj$model_rmse,
#                   as.numeric(dml_obj$rmses["ml_l"]),
#                   as.numeric(dml_obj$rmses["ml_r"]),
#                   dml_obj$coef_pi,
#                   dml_obj$se_pi,
#                   dml_obj$pval_pi,
#                   as.numeric(dml_obj$rmses["ml_m"]),
#                   dml_obj$ARF,
#                   dml_obj$ARFp,
#                   dml_obj$ARchi2p)
# #
# rownames(table)= c("Estimate theta", "Std. Error theta", "P-value theta",
#                    "Model RMSE", "MSE of l", "MSE of r",
#                    "Estimate pi", "Std. Error pi", "P-value pi", "MSE of m",
#                    "Estimate delta", "Std. Error delta", "P-value delta")
# colnames(table)= c( "DML-LASSO", "DML-CART", "DML-RF" , "DML-XGBOOST", "DML-Nnet")
# print(table)
#
# i = i + 1
}
}
zlist = names(select(dta, c("zweak","zweak2"))) #c("z","z2","z3")
yvar = names(select(dta, c("y_31")))
dvar = names(select(dta, c("d_31")))
obj_dml_data = dml_transform_data_from_data_frame(dta,
x_cols = c(x_cols,Lx_cols),  y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols = "id")
print(obj_dml_data)
#______________________________________________________________________________#
rm(table)
table = matrix(0, 13,5)
i = 1
approaches <- c('exact') #, 'wg')
learners   <- c('rpart') #'lasso', 'rpart', 'rf','xgboost','nnet')
for (appr in approaches){
for (lrn in learners){
print(glue("Learner: {lrn}; approach: {appr}"))
#______________________________________________________________________________#
# Simulation parameters
#______________________________________________________________________________#
set.seed(1408)
# Set up DML data and estimation environment (calls functions in 003_dml_functions_approx_and_exact.R)
if({lrn}=="lasso"){
dml_obj = dml_lasso(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="rf"){
dml_obj = dml_rf(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="rpart"){
dml_obj = dml_rpart(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if({lrn}=="xgboost"){
dml_obj = dml_xgboost(df = dta,
x_cols = c(x_cols, Lx_cols), y_col = yvar, d_cols = dvar, z_cols = zlist,
cluster_cols="id")
}else if ({lrn}=="nnet"){
# min-max normalisation
main = select(dta, c(x_cols, Lx_cols))
maxs = apply(main, 2, max)
mins = apply(main, 2, min)
scaled = as.data.frame(scale(main, center = mins, scale = maxs - mins))
scaled$y = dta[[yvar]]
scaled$id= dta$id
scaled$time = dta$time
scaled$d = dta[[dvar]]
scaled$z = dta[zlist]
dta2 <- scaled %>% select(c(id,time,y,d,z), everything())
#z = paste0("x", 29:30)
dml_obj = dml_nnet(df = dta2,
x_cols = c(x_cols,Lx_cols), y_col = "y", d_cols = "d", z_cols = paste0("z.", zlist),
cluster_cols="id")
}
# DML estimation
dml_obj$fit()
dml_obj$print()
dml_obj$confint()
#print(dml_obj$params)
print(cat(paste0(dml_obj$ARroot1, collapse = "\n")))
print(cat(paste0(dml_obj$ARroot2, collapse = "\n")))
# # Display table that compares results
# table[,i] = cbind(dml_obj$coef_theta,
#                   dml_obj$se_theta,
#                   dml_obj$pval_theta,
#                   dml_obj$model_rmse,
#                   as.numeric(dml_obj$rmses["ml_l"]),
#                   as.numeric(dml_obj$rmses["ml_r"]),
#                   dml_obj$coef_pi,
#                   dml_obj$se_pi,
#                   dml_obj$pval_pi,
#                   as.numeric(dml_obj$rmses["ml_m"]),
#                   dml_obj$ARF,
#                   dml_obj$ARFp,
#                   dml_obj$ARchi2p)
# #
# rownames(table)= c("Estimate theta", "Std. Error theta", "P-value theta",
#                    "Model RMSE", "MSE of l", "MSE of r",
#                    "Estimate pi", "Std. Error pi", "P-value pi", "MSE of m",
#                    "Estimate delta", "Std. Error delta", "P-value delta")
# colnames(table)= c( "DML-LASSO", "DML-CART", "DML-RF" , "DML-XGBOOST", "DML-Nnet")
# print(table)
#
# i = i + 1
}
}
#______________________________________________________________________________#
# Title:  Check 'XTDML' R package
# Date: August 2025
# IN NAMESPACE add: importFrom(R6, R6Class)
#______________________________________________________________________________#
rm(list = ls())
wd.pack = "C:/Users/annal/Dropbox/IADS/dml/submissions/JSS/xtdml"
setwd(wd.pack)
devtools::check()
devtools::load_all()
devtools::load_all()
?xtdml
devtools::check()
?xtdml_plr
wd.pack = "C:/Users/annal/Dropbox/IADS/dml/submissions/JSS/xtdml"
setwd(wd.pack)
devtools::document()
devtools::document()         # Documents function.Rd in man folder
devtools::document()         # Documents function.Rd in man folder
#install.packages("mlr3pipelines")
# library(roxygen2)  # for documenting your functions
# library(devtools)  # for building R packages
library(mlr3pipelines)
install.packages('mlr3pipelines')
install.packages("mlr3pipelines")
devtools::document()         # Documents function.Rd in man folder
#______________________________________________________________________________#
# Title:  Check 'XTDML' R package
# Date: August 2025
# IN NAMESPACE add: importFrom(R6, R6Class)
#______________________________________________________________________________#
rm(list = ls())
wd.pack = "C:/Users/annal/Dropbox/IADS/dml/submissions/JSS/xtdml"
setwd(wd.pack)
devtools::document()         # Documents function.Rd in man folder
#install.packages("mlr3pipelines")
library(roxygen2)  # for documenting your functions
rlang::last_trace()
rlang::last_trace(drop = FALSE)
devtools::check()
devtools::check()
devtools::document()         # Documents function.Rd in man folder
devtools::check()
library(xtdml)
install.packages("roxygen2")
library(roxygen2)
roxygenise()
devtools::document()         # Documents function.Rd in man folder
install.packages("mlr3pipelines")
devtools::document()         # Documents function.Rd in man folder
##################
library(devtools)
install_github("POLSEAN/xtdml")
#______________________________________________________________________________#
# Title:  Check 'XTDML' R package
# Date: August 2025
# IN NAMESPACE add: importFrom(R6, R6Class)
#______________________________________________________________________________#
rm(list = ls())
library(devtools)
install_github("POLSEAN/xtdml")
library(xtdml)
version
version
devtools::document()         # Documents function.Rd in man folder
devtools::document()         # Documents function.Rd in man folder
devtools::check()
devtools::load_all()
library(xtdml)
?xtdml
devtools::check()
#______________________________________________________________________________#
# Title:  Check 'XTDML' R package
# Date: August 2025
# IN NAMESPACE add: importFrom(R6, R6Class)
#______________________________________________________________________________#
rm(list = ls())
wd.pack = "C:/Users/annal/Dropbox/IADS/dml/submissions/JSS/xtdml"
setwd(wd.pack)
devtools::document()         # Documents function.Rd in man folder
devtools::check()
pkgbuild::check_build_tools(debug = TRUE)
devtools::document()         # Documents function.Rd in man folder
devtools::document()         # Documents function.Rd in man folder
devtools::document()         # Documents function.Rd in man folder
devtools::check()
devtools::check()
