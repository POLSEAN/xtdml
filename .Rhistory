y_col_tilde = rep(NA,t_per*n_obs)
d_cols_tilde = rep(NA,t_per*n_obs)
x_cols_tilde = matrix(NA,nrow=n_obs*t_per,ncol=dim_x)
for(i in 1:n_obs){
indices = ((i-1)*t_per + 1):(i*t_per)
y_col_tilde[indices] = Pi_hat %*% t(t(y_col_vec[indices]))
d_cols_tilde[indices] = Pi_hat %*% t(t(d_cols_vec[indices]))
x_cols_tilde[indices,] = Pi_hat %*% t(t(x_cols_mat[indices,]))
}
set.seed(1235)
n_obs = 500; t_per = 100; dim_x = 30; r=2
# Load df
df = make_plpr_ife_data(n_obs = 500, t_per = 100, dim_x = 30, theta = 1, dgp="linear")
factor = matrix(rnorm(t_per * r, mean = 0, sd = 2), nrow = t_per, ncol = r)
Pi = diag(t_per) -  factor %*% solve(t(factor) %*% factor)  %*% t(factor)
y_col_vec = df$y
d_cols_vec = df$d
x_names = paste0("X",1:30)
x_cols_mat = as.matrix(df[ , x_names])
y_col_tilde = rep(NA,t_per*n_obs)
d_cols_tilde = rep(NA,t_per*n_obs)
x_cols_tilde = matrix(NA,nrow=n_obs*t_per,ncol=dim_x)
for(i in 1:n_obs){
indices = ((i-1)*t_per + 1):(i*t_per)
y_col_tilde[indices] = Pi %*% t(t(y_col_vec[indices]))
d_cols_tilde[indices] = Pi %*% t(t(d_cols_vec[indices]))
x_cols_tilde[indices,] = Pi %*% t(t(x_cols_mat[indices,]))
}
df2 = data.frame(setNames(list(y_col_tilde), "y"),
setNames(list(d_cols_tilde), "d"),
as.data.frame(x_cols_tilde))
df2$id   = df$id
df2$time = df$time
dim(x_cols_mat)
dim(x_cols_mat[indices,])
dim(t(t(x_cols_mat[indices,])))
dim(d_cols_vec[indices])
length(d_cols_vec[indices])
for(i in 1:n_obs){
indices = ((i-1)*t_per + 1):(i*t_per)
y_col_tilde[indices] = Pi %*% y_col_vec[indices]
d_cols_tilde[indices] = Pi %*% d_cols_vec[indices]
x_cols_tilde[indices,] = Pi %*% x_cols_mat[indices,]
}
x_cols = paste0("V", 1:30)
model <- interFE(
df = df2,
Y = "y",
X = c("d",x_cols),
index = c("id", "time"),
r = 2,
force = "none",
se = FALSE,
nboots = 10,
normalize = FALSE
)
################################
x_cols = paste0("V", 1:30)
model <- interFE(
df2,
Y = "y",
X = c("d",x_cols),
index = c("id", "time"),
r = 2,
force = "none",
se = FALSE,
nboots = 10,
normalize = FALSE
)
################################
x_cols = paste0("V", 1:30)
model <- interFE(
data = df2,
Y = "y",
X = c("d",x_cols),
index = c("id", "time"),
r = 2,
force = "none",
se = FALSE,
nboots = 10,
normalize = FALSE
)
print(model$est.table[1,])
pproaches = c("pooled","cre-ife") #, "fd-exact", "wg-approx")
for(approach in approaches){
obj_xtdml_df = xtdml_df_from_df_frame(df,
x_cols = x_cols,  y_col = "y", d_cols = "d",
panel_id = "id", time_id = "time", cluster_cols = "id",
approach = approach,
transformX = "poly")
#print(obj_xtdml_df)
set.seed(1408)
learner = lrn("regr.cv_glmnet", s="lambda.min")
ml_m = learner$clone()
ml_l = learner$clone()
# Set up estimation environmenr
xtdml_lasso = xtdml_plr$new(obj_xtdml_df,
ml_l = ml_l, ml_m = ml_m,
n_folds = 5, score = "orth-PO")
# DML Estimates
xtdml_lasso$fit()
xtdml_lasso$print()
}
approaches = c("pooled","cre-ife") #, "fd-exact", "wg-approx")
for(approach in approaches){
obj_xtdml_df = xtdml_df_from_df_frame(df2,
x_cols = x_cols,  y_col = "y", d_cols = "d",
panel_id = "id", time_id = "time", cluster_cols = "id",
approach = approach,
transformX = "poly")
#print(obj_xtdml_df)
set.seed(1408)
learner = lrn("regr.cv_glmnet", s="lambda.min")
ml_m = learner$clone()
ml_l = learner$clone()
# Set up estimation environmenr
xtdml_lasso = xtdml_plr$new(obj_xtdml_df,
ml_l = ml_l, ml_m = ml_m,
n_folds = 5, score = "orth-PO")
# DML Estimates
xtdml_lasso$fit()
xtdml_lasso$print()
}
##################################
approaches = c("pooled","cre-ife") #, "fd-exact", "wg-approx")
for(approach in approaches){
obj_xtdml_df = xtdml_df_from_data_frame(df2,
x_cols = x_cols,  y_col = "y", d_cols = "d",
panel_id = "id", time_id = "time", cluster_cols = "id",
approach = approach,
transformX = "poly")
#print(obj_xtdml_df)
set.seed(1408)
learner = lrn("regr.cv_glmnet", s="lambda.min")
ml_m = learner$clone()
ml_l = learner$clone()
# Set up estimation environmenr
xtdml_lasso = xtdml_plr$new(obj_xtdml_df,
ml_l = ml_l, ml_m = ml_m,
n_folds = 5, score = "orth-PO")
# DML Estimates
xtdml_lasso$fit()
xtdml_lasso$print()
}
approaches = c("pooled","cre-ife") #, "fd-exact", "wg-approx")
for(approach in approaches){
obj_xtdml_df = xtdml_data_from_data_frame(df2,
x_cols = x_cols,  y_col = "y", d_cols = "d",
panel_id = "id", time_id = "time", cluster_cols = "id",
approach = approach,
transformX = "poly")
#print(obj_xtdml_df)
set.seed(1408)
learner = lrn("regr.cv_glmnet", s="lambda.min")
ml_m = learner$clone()
ml_l = learner$clone()
# Set up estimation environmenr
xtdml_lasso = xtdml_plr$new(obj_xtdml_df,
ml_l = ml_l, ml_m = ml_m,
n_folds = 5, score = "orth-PO")
# DML Estimates
xtdml_lasso$fit()
xtdml_lasso$print()
}
generate_data <- function(obs_N, obs_T, p, mu, RHO){
# K = 3 Factors
K <- 3
# Generate beta
if((p-1) %% 3 > 0){
stop("beta can not be generated with group structure.")
}
if(p < 10){
beta <- rep(1, p)
group_size <- (p-1)/3
message( beta)
}else{
group_size <- (p-1)/3
beta_group <- c(1,1,1, rep(0, (group_size-3)))
beta <- c(1, rep(beta_group, 3))
message( beta)
}
X <- numeric(p)
Y <- numeric(1)
Y_INFERENCE <- numeric(3) # Generate response variable for inference
# Generate factors
F_1 <- as.vector(stats::arima.sim(model = list(ar = 0.5), n = obs_T,
innov = rnorm(n = obs_T, mean = 0, sd = sqrt(0.75))))
F_2 <- as.vector(stats::arima.sim(model = list(ar = 0.5), n = obs_T,
innov = rnorm(n = obs_T, mean = 0, sd = sqrt(0.75))))
F_3 <- as.vector(stats::arima.sim(model = list(ar = 0.5), n = obs_T,
innov = rnorm(n = obs_T, mean = 0, sd = sqrt(0.75))))
F_matrix <- cbind(F_1, F_2, F_3)
# Oracle projection matrix
Pi <- diag(1, obs_T, obs_T) - F_matrix %*% solve((t(F_matrix) %*% F_matrix)) %*% t(F_matrix)
# Covariance matrix of G_i
Sigma_G <- matrix(RHO, nrow = (K + p - 1 ),
ncol = (K + p - 1)) + diag(1 - RHO, nrow = (K + p - 1 ),
ncol = (K + p - 1))
# Idiosyncratic error iid across i and t
eps <- rnorm(n = obs_N * obs_T, mean = 0, sd = 1)
# Nodewise errors iid across i and t
u <- rnorm(n = obs_N * obs_T, mean = 0, sd = 1)
# Idiosyncratic regressors
Z <- mvtnorm::rmvnorm(n = obs_N * obs_T, mean = rep(0, (p - 1),
sd = diag(1, nrow = (p - 1),
ncol = (p - 1) )))
G_i <- mvtnorm::rmvnorm(obs_N, mean = mu, sigma = Sigma_G)
for (i in 1:obs_N) {################# Start iteration i #################
gamma_i <- G_i[i,1:K]
Gamma_i <- cbind(c(G_i[i, (K + 1):(K + group_size)], rep(0, 2 * group_size)),
c(rep(0, group_size), G_i[i, (K + group_size + 1):(K + 2 * group_size)], rep(0, group_size)),
c(rep(0, 2 * group_size), G_i[i, (K + 2 * group_size + 1):(K + 3 * group_size)]))
# Regressors generated with factor structure
X_i <- F_matrix %*% t(Gamma_i) + Z[((i-1) * obs_T + 1) : (i * obs_T),]
# First regressor generated with nodewise structure
X_i1 <- X_i[, 1] * sqrt(2/3) + u[((i-1) * obs_T + 1) : (i * obs_T)]
# Collect the design X_i in a first step
X_i <- cbind(X_i1, X_i)
# Generate response variable Y
Y_i <- X_i %*% beta + F_matrix %*% gamma_i + eps[((i-1) * obs_T + 1) : (i * obs_T)]
# Generate response Y for INFERENCE
Y_INFERENCE_i <- matrix(nrow = obs_T, ncol = 3)
k <- 1
for (signal in c(0, 0.1, 0.2)) {
beta_INFERENCE <- beta
beta_INFERENCE[1] <- signal
Y_INFERENCE_i[,k] <- X_i %*% beta_INFERENCE + F_matrix %*% gamma_i + eps[((i-1) * obs_T + 1) : (i * obs_T)]
k <- k + 1
}
# Collect the data
X <- rbind(X, X_i)
Y <- rbind(Y, Y_i)
Y_INFERENCE <- rbind(Y_INFERENCE, Y_INFERENCE_i)
} ################# End iteration i #################
return(list(data_estimation = list(x = X[-1,], y = Y[-1]),
data_inference = list(x = X[-1,], y = Y_INFERENCE[-1,])))
}
obs_N = 500; obs_T = 10; p = 30; RHO=.25
mu <- c(1, 1, 1, rep(1, (p-1)))
data = generate_data(obs_N, obs_T, p, mu, RHO)
obs_N = 500; obs_T = 10; p = 10; RHO=.25
mu <- c(1, 1, 1, rep(1, (p-1)))
data = generate_data(obs_N, obs_T, p, mu, RHO)
data
names(data)
rm(data)
set.seed(1234)
n_obs = 1000; t_per = 10
p = 30; theta = 1; r = 2; rho = 0.6
a_1 = 0.25; a_2 = 0.5; b_1 = 0.5; b_2 = 0.25
time = rep(1:t_per, times=n_obs, each=1)
id   = rep(1:n_obs, times=1, each=t_per)
nt = n_obs * t_per
df = data.frame(id, time)
# Factor loadings: n x r
Lambda <- matrix(rnorm(n_obs * r, sd = 1), nrow = n_obs, ncol = r)
# Time factors: t x r
F_t <- matrix(rnorm(t_per * r, sd = 1), nrow = t_per, ncol = r)
# IFE for each (i,t): reshape F_t %*% t(Lambda) to nt vector
IFE_mat <- F_t %*% t(Lambda)      # t_per x n_obs
IFE_vec <- as.vector(t(IFE_mat))  # Column-wise unrolling (matches panel)
# Covariates X: each affected by IFE + noise
X <- matrix(NA, nrow = nt, ncol = p)
for (j in 1:p) {
X[, j] <- IFE_vec + rnorm(nt)
}
colnames(X) <- paste0("X", 1:p)
# nuisance functions
m0   =  a_1 * X[, 1] + a_2 * X[, 3]
g0   =  b_1 * X[, 1] + b_2 * X[, 3]
#m0   =  a_1 * (X[, 1] * as.numeric(X[, 1]>0)) + a_2 * (X[, 3] * X[, 1])
#g0   =  b_1 * (X[, 3] * X[, 1]) + b_2 * (X[, 3] * as.numeric(X[, 3]>0))
d = m0 + IFE_vec + rnorm(nt, sd = 1)
y = theta * D + g_0 + IFE_vec + rnorm(nt, sd = 1)
rm(data)
set.seed(1234)
n_obs = 1000; t_per = 10
p = 30; theta = 1; r = 2; rho = 0.6
a_1 = 0.25; a_2 = 0.5; b_1 = 0.5; b_2 = 0.25; theta=1
time = rep(1:t_per, times=n_obs, each=1)
id   = rep(1:n_obs, times=1, each=t_per)
nt = n_obs * t_per
df = data.frame(id, time)
# Factor loadings: n x r
Lambda <- matrix(rnorm(n_obs * r, sd = 1), nrow = n_obs, ncol = r)
# Time factors: t x r
F_t <- matrix(rnorm(t_per * r, sd = 1), nrow = t_per, ncol = r)
# IFE for each (i,t): reshape F_t %*% t(Lambda) to nt vector
IFE_mat <- F_t %*% t(Lambda)      # t_per x n_obs
IFE_vec <- as.vector(t(IFE_mat))  # Column-wise unrolling (matches panel)
# Covariates X: each affected by IFE + noise
X <- matrix(NA, nrow = nt, ncol = p)
for (j in 1:p) {
X[, j] <- IFE_vec + rnorm(nt)
}
colnames(X) <- paste0("X", 1:p)
# nuisance functions
m0   =  a_1 * X[, 1] + a_2 * X[, 3]
g0   =  b_1 * X[, 1] + b_2 * X[, 3]
#m0   =  a_1 * (X[, 1] * as.numeric(X[, 1]>0)) + a_2 * (X[, 3] * X[, 1])
#g0   =  b_1 * (X[, 3] * X[, 1]) + b_2 * (X[, 3] * as.numeric(X[, 3]>0))
d = m0 + IFE_vec + rnorm(nt, sd = 1)
y = theta * D + g_0 + IFE_vec + rnorm(nt, sd = 1)
y = theta * d + g_0 + IFE_vec + rnorm(nt, sd = 1)
y = theta * d + g0 + IFE_vec + rnorm(nt, sd = 1)
df3 <- data.frame(id = id,
time = time,
y = y,
d = d,
X)
x_cols = paste0("X", 1:30)
model <- interFE(
data = df,
Y = "y",
X = c("d",x_cols),
index = c("id", "time"),
r = 2,
force = "none",
se = FALSE,
nboots = 10,
normalize = FALSE
)
x_cols = paste0("X", 1:30)
model <- interFE(
data = df3,
Y = "y",
X = c("d",x_cols),
index = c("id", "time"),
r = 2,
force = "none",
se = FALSE,
nboots = 10,
normalize = FALSE
)
print(model$est.table[1,])
m(df3)
rm(df3)
set.seed(1234)
n_obs = 500; t_per = 100
p = 30; theta = 1; r = 2; rho = 0.6
a_1 = 0.25; a_2 = 0.5; b_1 = 0.5; b_2 = 0.25; theta=1
time = rep(1:t_per, times=n_obs, each=1)
id   = rep(1:n_obs, times=1, each=t_per)
nt = n_obs * t_per
df = data.frame(id, time)
# Factor loadings: n x r
Lambda <- matrix(rnorm(n_obs * r, sd = 1), nrow = n_obs, ncol = r)
# Time factors: t x r
F_t <- matrix(rnorm(t_per * r, sd = 1), nrow = t_per, ncol = r)
# IFE for each (i,t): reshape F_t %*% t(Lambda) to nt vector
IFE_mat <- F_t %*% t(Lambda)      # t_per x n_obs
IFE_vec <- as.vector(t(IFE_mat))  # Column-wise unrolling (matches panel)
# Covariates X: each affected by IFE + noise
X <- matrix(NA, nrow = nt, ncol = p)
for (j in 1:p) {
X[, j] <- IFE_vec + rnorm(nt)
}
colnames(X) <- paste0("X", 1:p)
# nuisance functions
m0   =  a_1 * X[, 1] + a_2 * X[, 3]
g0   =  b_1 * X[, 1] + b_2 * X[, 3]
#m0   =  a_1 * (X[, 1] * as.numeric(X[, 1]>0)) + a_2 * (X[, 3] * X[, 1])
#g0   =  b_1 * (X[, 3] * X[, 1]) + b_2 * (X[, 3] * as.numeric(X[, 3]>0))
d = m0 + IFE_vec + rnorm(nt, sd = 1)
y = theta * d + g0 + IFE_vec + rnorm(nt, sd = 1)
df3 <- data.frame(id = id,
time = time,
y = y,
d = d,
X)
x_cols = paste0("X", 1:30)
model <- interFE(
data = df3,
Y = "y",
X = c("d",x_cols),
index = c("id", "time"),
r = 2,
force = "none",
se = FALSE,
nboots = 10,
normalize = FALSE
)
print(model$est.table[1,])
#1.033228
devtools::load_all()
approaches = c("pooled","cre-ife") #, "fd-exact", "wg-approx")
for(approach in approaches){
obj_xtdml_data = xtdml_data_from_data_frame(df3,
x_cols = x_cols,  y_col = "y", d_cols = "d",
panel_id = "id", time_id = "time", cluster_cols = "id",
approach = approach,
transformX = "poly")
#print(obj_xtdml_data)
set.seed(1408)
learner = lrn("regr.cv_glmnet", s="lambda.min")
ml_m = learner$clone()
ml_l = learner$clone()
# Set up estimation environmenr
xtdml_lasso = xtdml_plr$new(obj_xtdml_data,
ml_l = ml_l, ml_m = ml_m,
n_folds = 5, score = "orth-PO")
# DML Estimates
xtdml_lasso$fit()
xtdml_lasso$print()
}
rm(df3)
set.seed(1234)
n_obs = 500; t_per = 100
p = 30; theta = 1; r = 2; rho = 0.6
a_1 = 0.25; a_2 = 0.5; b_1 = 0.5; b_2 = 0.25; theta=1
time = rep(1:t_per, times=n_obs, each=1)
id   = rep(1:n_obs, times=1, each=t_per)
nt = n_obs * t_per
df = data.frame(id, time)
# Factor loadings: n x r
Lambda <- matrix(rnorm(n_obs * r, sd = 1), nrow = n_obs, ncol = r)
# Time factors: t x r
F_t <- matrix(rnorm(t_per * r, sd = 1), nrow = t_per, ncol = r)
# IFE for each (i,t): reshape F_t %*% t(Lambda) to nt vector
IFE_mat <- F_t %*% t(Lambda)      # t_per x n_obs
IFE_vec <- as.vector(t(IFE_mat))  # Column-wise unrolling (matches panel)
# Covariates X: each affected by IFE + noise
X <- matrix(NA, nrow = nt, ncol = p)
for (j in 1:p) {
X[, j] <- IFE_vec + rnorm(nt)
}
colnames(X) <- paste0("X", 1:p)
# nuisance functions
# m0   =  a_1 * X[, 1] + a_2 * X[, 3]
# g0   =  b_1 * X[, 1] + b_2 * X[, 3]
m0   =  a_1 * (X[, 1] * as.numeric(X[, 1]>0)) + a_2 * (X[, 3] * X[, 1])
g0   =  b_1 * (X[, 3] * X[, 1]) + b_2 * (X[, 3] * as.numeric(X[, 3]>0))
d = m0 + IFE_vec + rnorm(nt, sd = 1)
y = theta * d + g0 + IFE_vec + rnorm(nt, sd = 1)
df3 <- data.frame(id = id,
time = time,
y = y,
d = d,
X)
x_cols = paste0("X", 1:30)
model <- interFE(
data = df3,
Y = "y",
X = c("d",x_cols),
index = c("id", "time"),
r = 2,
force = "none",
se = FALSE,
nboots = 10,
normalize = FALSE
)
print(model$est.table[1,])
approaches = c("pooled","cre-ife") #, "fd-exact", "wg-approx")
for(approach in approaches){
obj_xtdml_data = xtdml_data_from_data_frame(df3,
x_cols = x_cols,  y_col = "y", d_cols = "d",
panel_id = "id", time_id = "time", cluster_cols = "id",
approach = approach,
transformX = "poly")
#print(obj_xtdml_data)
set.seed(1408)
learner = lrn("regr.cv_glmnet", s="lambda.min")
ml_m = learner$clone()
ml_l = learner$clone()
# Set up estimation environmenr
xtdml_lasso = xtdml_plr$new(obj_xtdml_data,
ml_l = ml_l, ml_m = ml_m,
n_folds = 5, score = "orth-PO")
# DML Estimates
xtdml_lasso$fit()
xtdml_lasso$print()
}
approaches =  "wg-approx" #c("pooled","cre-ife") #, "fd-exact", "wg-approx")
for(approach in approaches){
obj_xtdml_data = xtdml_data_from_data_frame(df3,
x_cols = x_cols,  y_col = "y", d_cols = "d",
panel_id = "id", time_id = "time", cluster_cols = "id",
approach = approach,
transformX = "poly")
#print(obj_xtdml_data)
set.seed(1408)
learner = lrn("regr.cv_glmnet", s="lambda.min")
ml_m = learner$clone()
ml_l = learner$clone()
# Set up estimation environmenr
xtdml_lasso = xtdml_plr$new(obj_xtdml_data,
ml_l = ml_l, ml_m = ml_m,
n_folds = 5, score = "orth-PO")
# DML Estimates
xtdml_lasso$fit()
xtdml_lasso$print()
}
approaches =  "fd-exact" #c("pooled","cre-ife") #, "fd-exact", "wg-approx")
for(approach in approaches){
obj_xtdml_data = xtdml_data_from_data_frame(df3,
x_cols = x_cols,  y_col = "y", d_cols = "d",
panel_id = "id", time_id = "time", cluster_cols = "id",
approach = approach,
transformX = "poly")
#print(obj_xtdml_data)
set.seed(1408)
learner = lrn("regr.cv_glmnet", s="lambda.min")
ml_m = learner$clone()
ml_l = learner$clone()
# Set up estimation environmenr
xtdml_lasso = xtdml_plr$new(obj_xtdml_data,
ml_l = ml_l, ml_m = ml_m,
n_folds = 5, score = "orth-PO")
# DML Estimates
xtdml_lasso$fit()
xtdml_lasso$print()
}
